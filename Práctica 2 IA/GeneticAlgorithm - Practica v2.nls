;; Individuals = possible solutions

breed [AI:individuals AI:individual]

AI:individuals-own [
  content  ; Where the representation of the solution is stored in the individual
  fitness  ; Where the fitness of the individual is stored
]
;---------------------------------------------------------------------------------

to-report AI:PointCrossover [c1 c2]
  ;beta random 0..1
  let beta random-float 1
  
  ;Punto de cruce
  let index (random (length c1))
  
  let p1n ((item index c2) - beta * ((item index c2) - (item index c1))) 
  let p2n ((item index c1) - beta * ((item index c1) - (item index c2))) 
  
  let h1 sublist c1 0 (index - 1) 
  let h2 sublist c2 0 (index - 1)
  
  set h1 (lput p1n h1)
  set h2 (lput p2n h2)
  
  (foreach (range (index + 1) (length c1))[i -> set h1 (lput (item i c2) h1) set h2 (lput (item i c1) h2)])
  
  report list (sentence h1) (sentence h2)
  
 end

to-report AI:2PointCrossover [c1 c2]
  
  let index1 0
  let index2 0
  
  while[index1 >= index2][
    set index1 random length c1
    set index2 random length c1
  ]
  
  let h1 sublist c1 0 index1
  let h2 sublist c2 0 index1
  
  (foreach (range index1 (length c1))[i -> 
    ifelse(i < index2 and (random 1) = 1)[set h1 (lput (item i c2) h1) set h2 (lput (item i c1) h2)]
    [set h1 (lput (item i c1) h1) set h2 (lput (item i c2) h2)]])
  
  report list (sentence h1) (sentence h2)
  
end

to-report AI:UniformCrossover [c1 c2]
  
  let h1 []
  let h2 []
  
  (foreach c1 c2
  [[p1 p2] -> ifelse(p1 != p2 and (random 1) = 1)[set h1 (lput p2 h1) set h2 (lput p1 h2)]
    [set h1 (lput p1 h1) set h2 (lput p2 h2)]])
  
  report list (sentence h1) (sentence h2)
  
end

to-report AI:GeneticAlgorithm [#num-iters #population #crossover-ratio #mutation-ratio]
  repeat #num-iters [
    AI:Create-next-generation #population #crossover-ratio #mutation-ratio
    AI:ExternalUpdate
  ]
  report max-one-of AI:individuals [fitness]
end



to AI:Create-next-generation [#population #crossover-ratio #mutation-ratio]
  
  ; Start making a copy of the current pool
  let old-generation AI:individuals with [true]

  ; Decide how many crossover will be made (in each crossover 2 new individuals
  ; will be created)
  let number-crossovers  (floor (#population * #crossover-ratio / 100 / 2))

  ; Make Crossovers
  repeat number-crossovers
  [
    ; Tournament 3 selection: we take 3 random individuals and choose the best 
    ; of them. Selectors will be the parents of the new spring.

    let father1 max-one-of (n-of 3 old-generation) [fitness]
    let father2 max-one-of (n-of 3 old-generation) [fitness]

    (ifelse
      algCrossover = 0 [let content-child AI:UniformCrossover ([content] of father1) ([content] of father2)]
      algCrossover = 1 [let content-child AI:PointCrossover ([content] of father1) ([content] of father2)]
      algCrossover = 2 [let content-child AI:2PointCrossover ([content] of father1) ([content] of father2)]
      algCrossover = 3 [let content-child AI:CustomCrossover ([content] of father1) ([content] of father2)]
    
    )
    let content-child AI:crossover ([content] of father1) ([content] of father2)

    ; From 2 parents we create 2 children
    ask father1 [ hatch-AI:individuals 1 [ set content item 0 content-child ] ]
    ask father2 [ hatch-AI:individuals 1 [ set content item 1 content-child ] ]
  ]

  ; The rest of pool will be cloned directly from good individuals of the
  ; previous generation
  repeat (#population - number-crossovers * 2)
  [
    ask max-one-of (n-of 3 old-generation) [fitness]
      [ hatch-AI:individuals 1 ]
  ]

  ; Remove the previous generation
  ask old-generation [ die ]

  ; Mutate the new spring and compute the new fitness
  ask AI:individuals
  [
    AI:mutate #mutation-ratio
    AI:Compute-fitness
  ]
end

;------------------------------------------------------------------------------
; Hemos mejorado algunos procedimientos auxiliares que calculan la diversidad del mundo
; usando la distancia Hamming entre todos los pares de individuos
; We provide some auxiliary procedures that calculate the diversity of the pool
;  (using the Hamming distance between all individual pairs)

; Provided diversity is the average of Hamming distances between all pairs 
; in the population.

to-report AI:diversity
  let distances []
  ask AI:individuals [
    let c1 content
    ask AI:individuals with [self > myself] [
      set distances fput (AI:distance content c1) distances
    ]
  ]
  report mean distances
end

to-report AI:distance [c1 c2]
  report hamming-distance c1 c2
end

; Hamming Distance between two lists is the proportion of positions they 
; differ.
to-report hamming-distance [c1 c2]
  report (length remove true (map [[x1 x2] -> x1 = x2] c1 c2)) / (length c1)
end
